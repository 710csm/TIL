# 빅오(Big-O)
- 빅오(Big-O)는 시공간 복잡도를 수학적으로 표시하는 대표적인 방법이다. 단, 코드의 실제 러닝 타임을 표시하는 것이 아니고, input 데이터의 증가율에 따른 알고리즘의 성능을 예측하기 위해 사용한다.

## 빅오 표기법 특징
1. 상수항 무시: 빅오 표기법은 데이터 입력값(n)이 충분히 크다고 가정하고 있고, 알고리즘의 효율성 또한 데이터 입력값(n)의 크기에 따라 영향을 받기 때문에 상수항 같은 사소한 부분은 무시한다.
    
    - O(2n) -> O(n)와 같이 상수항은 무시하고 표기한다.

2. 영향령이 없는 항은 무시: 빅오 표기법은 데이터의 입력값(n)의 크기에 따라 영향을 받기 때문에 가장 영향력이 큰항 이외에 영향력 없는 항들은 무시한다.

    - O(n^2 + 2n + 1) -> O(n^2)와 같이 영향력이 지배적인 n^2 이외에 영향력이 없는 항들은 무시한다.
    
## 빅오 표기법 성능비교
- 빅오 표기법에서 주로 사용되는 표기법은 아래와 같다.

<img width="760" alt="스크린샷 2022-05-02 오전 10 33 03" src="https://user-images.githubusercontent.com/45002556/166174319-2ad745db-2132-4041-95af-5ee243f8e8e0.png">

- O(1) < O(log n) < O(n) < O(n log n) < O(n^2) < O(2^n) 의 순서로 나타낼 수 있다.

1. O(1) (Constant)
    - 입력 데이터의 크기에 상관없이 언제나 일정한 시간이 걸리는 알고리즘을 나타낸다. 데이터가 얼마나 증가하든 성능에 영향을 거의 미치지 않는다.

2. O(log n) (Logarithmic)
    - 입력 데이터의 크기가 커질 수록 처리 시간이 로그(log: 지수 함수의 역함수) 만큼 짧아지는 알고리즘이다. 예를 들어 데이터가 10배가 되면, 처리 시간은 2배가 된다. 이진 탐색이 대표적이며, 재귀가 순기능으로 이루어지는 경우도 해당된다.

3. O(n) (Linear)
    - 입력 데이터의 크기에 비례해 처리 시간이 증가하는 알고리즘이다. 예를 들어 데이터가 10배가 되면, 처리 시간도 10배가 된다. 선형 탐색 알고리즘이 대표적이다.

4. O(n log n) (Linear-Logarithmic)
    - 데이터가 많아질수록 처리시간이 로그(log) 배 만큼 더 늘어나는 알고리즘이다. 예를 들어 데이터가 10배가 되면, 처리 시간은 약 20배가 된다. 정렬 알고리즘 Merge sort, Quick sort의 평균 시간 복잡도이다.

5. O(n²) (quadratic)
    - 데이터가 많아질수록 처리시간이 급수적으로 늘어나는 알고리즘이다. 예를 들어 데이터가 10배가 되면, 처리 시간은 최대 100배가 된다. 이중 루프(n² matrix)가 대표적이다. 단, m이 n보다 작을 때는 반드시 O(nm)로 표시하는것이 바람직하다.

6. O(2ⁿ) (Exponential)
    - 데이터량이 많아질수록 처리시간이 기하급수적으로 늘어나는 알고리즘이다. 대표적으로 피보나치 수열이 있으며, 재귀가 역기능을 할 경우도 해당된다.

### Swift의 sort의 시간 복잡도
- 최악의 경우 O(n log n)이고 최적의 경우 O(n) 이다. 
